package org.globe42.domain

import java.time.LocalDate
import java.util.*
import javax.persistence.*
import javax.validation.Valid
import javax.validation.constraints.Email
import javax.validation.constraints.NotEmpty
import javax.validation.constraints.NotNull
import javax.validation.constraints.Pattern

const val FISCAL_NUMBER_REGEXP = "\\d{13}|^$"
private const val PERSON_GENERATOR = "PersonGenerator"

/**
 * A person helped by, or member of Globe 42.
 * There are two main kinds of persons. Those for whom mediation is done by Globe 42, and the others.
 * For those who have mediation enabled, a mediation code is generated by the application, and several additional
 * fields are requested about them.
 * @author JB Nizet
 */
@Entity
class Person {

    @Id
    @SequenceGenerator(name = PERSON_GENERATOR, sequenceName = "PERSON_SEQ", initialValue = 1000, allocationSize = 1)
    @GeneratedValue(generator = PERSON_GENERATOR)
    var id: Long? = null

    /**
     * The first name, requested to all persons, and mandatory
     */
    @NotEmpty
    lateinit var firstName: String

    /**
     * The last name, requested to all persons, and mandatory
     */
    @NotEmpty
    lateinit var lastName: String

    /**
     * The birth name, requested to all persons, but not mandatory.
     * The birth name could be the maiden name of a married woman, for instance
     */
    var birthName: String? = null

    /**
     * The nick name, requested to all persons, but not mandatory
     */
    var nickName: String? = null

    /**
     * The gender of the person, requested to all persons, and mandatory
     */
    @NotNull
    @Enumerated(EnumType.STRING)
    lateinit var gender: Gender

    /**
     * The birth date, requested to all persons, but not mandatory
     */
    var birthDate: LocalDate? = null

    /**
     * The first address line (street and number, typically) of the person. Requested to all persons, but not mandatory
     */
    var address: String? = null

    /**
     * The postal code and city of the person. Requested to all persons, but not mandatory
     */
    @Embedded
    @Valid
    var city: City? = null

    /**
     * The email of the person. Requested to all persons, but not mandatory
     */
    @Email
    var email: String? = null

    /**
     * The phone number of the person. Requested to all persons, but not mandatory
     */
    var phoneNumber: String? = null

    /**
     * Is mediation enabled for the person or not. Requested to all persons, and mandatory.
     */
    var mediationEnabled: Boolean = false

    /**
     * The mediation code, generated automatically for mediation-enabled persons only, from the first letter of the
     * last name, and from a sequence.
     */
    var mediationCode: String? = null

    /**
     * The date of first mediation appointment. Only requested to mediation-enabled persons, but not mandatory
     */
    var firstMediationAppointmentDate: LocalDate? = null

    /**
     * The date of entry in France. Only requested to mediation-enabled persons, but not mandatory
     */
    var entryDate: LocalDate? = null

    /**
     * The type of entry in France. Only requested to mediation-enabled persons, but not mandatory
     */
    @NotNull
    @Enumerated(EnumType.STRING)
    var entryType: EntryType = EntryType.UNKNOWN

    /**
     * The marital status. Only requested to mediation-enabled persons, and unknown by default (so, technically
     * mandatory, but can be left as unknown)
     */
    @NotNull
    @Enumerated(EnumType.STRING)
    var maritalStatus = MaritalStatus.UNKNOWN

    /**
     * The couple (marriage, PACS, etc.) in which the person is engaged with another person. Only requested to
     * mediation-enabled persons, and not mandatory. Note that it would make sense to only have a couple if
     * for some marital statuses, but no such check is made for now (in case we would preserve this association
     * for later).
     * Also note that, if the person is in couple with someone which is not a Person (i.e. a person outside of the
     * database), then this field is null and the field partner is filled instead.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    var couple: Couple? = null

    /**
     * The partner that this person is in couple with, if he/she's not a person in the database
     */
    var partner: String? = null

    /**
     * The housing kind. Only requested to mediation-enabled persons, and unknown by default (so, technically
     * mandatory, but can be left as unknown)
     */
    @NotNull
    @Enumerated(EnumType.STRING)
    var housing = Housing.UNKNOWN

    /**
     * The housing space, in square meters. Only requested to mediation-enabled persons, and not mandatory
     */
    var housingSpace: Int? = null

    /**
     * The name of the host, requested to all persons, but not mandatory.
     */
    var hostName: String? = null

    /**
     * The fiscal status. Only requested to mediation-enabled persons, and unknown by default (so, technically
     * mandatory, but can be left as unknown)
     */
    @NotNull
    @Enumerated(EnumType.STRING)
    var fiscalStatus = FiscalStatus.UNKNOWN

    /**
     * The fiscal number. Only requested to mediation-enabled persons, if the fiscal status is not
     * [FiscalStatus.UNKNOWN]. It's composed of 13 digits (see
     * https://cfsmsp.impots.gouv.fr/secavis/faces/commun/aideSpi.jsf)
     */
    @Pattern(regexp = FISCAL_NUMBER_REGEXP)
    var fiscalNumber: String? = null

    /**
     * Is the fiscal status up-to-date. Only requested to mediation-enabled persons, if the fiscal
     * status is not [FiscalStatus.UNKNOWN].
     */
    var fiscalStatusUpToDate: Boolean = false

    /**
     * The incomes of the person. Only requested to mediation-enabled persons
     */
    @OneToMany(mappedBy = "person", cascade = [CascadeType.ALL], orphanRemoval = true)
    private val incomes: MutableSet<Income> = HashSet()

    /**
     * The charges of the person. Only requested to mediation-enabled persons
     */
    @OneToMany(mappedBy = "person", cascade = [CascadeType.ALL], orphanRemoval = true)
    private val charges: MutableSet<Charge> = HashSet()

    /**
     * The per unit revenue information, containing a description of the members of the household needed to compute
     * the per unit revenue
     */
    var perUnitRevenueInformation: PerUnitRevenueInformation? = null

    /**
     * The Health Care Coverage. Only requested to mediation-enabled persons, and unknown by default (so, technically
     * mandatory, but can be left as unknown)
     */
    @NotNull
    @Enumerated(EnumType.STRING)
    var healthCareCoverage = HealthCareCoverage.UNKNOWN

    /**
     * The date when the health care coverage has been established/started. Only requested to mediation-enabled persons,
     * and when the health care coverage is not UNKNOWN
     */
    var healthCareCoverageStartDate: LocalDate? = null

    /**
     * The Health Insurance.  Only requested to mediation-enabled persons, and unknown by default (so, technically
     * mandatory, but can be left as unknown)
     */
    @NotNull
    @Enumerated(EnumType.STRING)
    var healthInsurance = HealthInsurance.UNKNOWN

    /**
     * The date when the health care coverage has been established/started. Only requested to mediation-enabled persons,
     * and when the health insurance is known
     */
    var healthInsuranceStartDate: LocalDate? = null

    /**
     * The name of the accompanying. Only requested to mediation-enabled persons, and not mandatory
     */
    var accompanying: String? = null

    /**
     * The social security number of the person. Only requested to mediation-enabled persons, and not mandatory.
     * In positions 6 and 7 of this number we have the 'place of birth" and we can have letters for people born abroad.
     * So we must have 'String' for the Type of this attribute.
     */
    var socialSecurityNumber: String? = null

    /**
     * The CAF number of the person. CAF = "Caisse Allocations Familiales" in French. Only requested to
     * mediation-enabled persons, and not mandatory
     */
    var cafNumber: String? = null

    /**
     * The nationality of the person. Only requested to mediation-enabled persons, and not mandatory
     */
    @ManyToOne(fetch = FetchType.LAZY)
    var nationality: Country? = null

    /**
     * Does the person have a passport. Only requested to mediation-enabled persons.
     */
    @Enumerated(EnumType.STRING)
    var passportStatus: PassportStatus = PassportStatus.UNKNOWN

    /**
     * The passport number. Only requested to mediation-enabled persons who have a passport, and not mandatory.
     */
    var passportNumber: String? = null

    /**
     * The passport validity start date. Only requested to mediation-enabled persons who have a passport, and not mandatory.
     */
    var passportValidityStartDate: LocalDate? = null

    /**
     * The passport validity end date. Only requested to mediation-enabled persons who have a passport, and not mandatory.
     */
    var passportValidityEndDate: LocalDate? = null

    /**
     * The visa type. Only requested to mediation-enabled persons, and unknown by default (so, technically
     * mandatory, but can be left as unknown)
     */
    @NotNull
    @Enumerated(EnumType.STRING)
    var visa = Visa.UNKNOWN

    /**
     * The type of residence permit. Only requested to mediation-enabled persons, and unknown by default (so, technically
     * mandatory, but can be left as unknown)
     */
    @NotNull
    @Enumerated(EnumType.STRING)
    var residencePermit = ResidencePermit.UNKNOWN

    /**
     * The date of the deposit of the residence permit for France. Only requested to mediation-enabled persons, but not mandatory
     */
    var residencePermitDepositDate: LocalDate? = null

    /**
     * The date of the renewal of the residence permit for France. Only requested to mediation-enabled persons, but not mandatory
     */
    var residencePermitRenewalDate: LocalDate? = null

    /**
     * The validity start date of the residence permit for France. Only requested to mediation-enabled persons, but not mandatory
     */
    var residencePermitValidityStartDate: LocalDate? = null

    /**
     * The validity end date of the residence permit for France. Only requested to mediation-enabled persons, but not mandatory
     */
    var residencePermitValidityEndDate: LocalDate? = null

    /**
     * The notes added on the person
     */
    @OneToMany(cascade = [CascadeType.ALL], orphanRemoval = true)
    @JoinTable(
        name = "person_note",
        joinColumns = [JoinColumn(name = "person_id")],
        inverseJoinColumns = [JoinColumn(name = "note_id")]
    )
    private val notes: MutableSet<Note> = HashSet()

    /**
     * The participations to activity types of the person
     */
    @OneToMany(mappedBy = "person", cascade = [CascadeType.ALL], orphanRemoval = true)
    private val participations: MutableSet<Participation> = HashSet()

    /**
     * The wedding events of the person. Only requested to mediation-enabled persons.
     */
    @OneToMany(mappedBy = "person", cascade = [CascadeType.ALL], orphanRemoval = true)
    private val weddingEvents: MutableSet<WeddingEvent> = HashSet()

    /**
     * The members of the network of the person. Only requested to mediation-enabled persons
     */
    @OneToMany(mappedBy = "person", cascade = arrayOf(CascadeType.ALL), orphanRemoval = true)
    private val networkMembers: MutableSet<NetworkMember> = HashSet()

    /**
     * Flag indicating that the given person is logically deleted
     */
    var deleted: Boolean = false

    /**
     * The date of death of the person
     */
    var deathDate: LocalDate? = null

    val spouse: Person?
        get() = couple?.getSpouseOf(this)

    /**
     * The family situation of the person. Only requested to mediation-enabled persons, and not mandatory.
     */
    @OneToOne(fetch = FetchType.LAZY, cascade = [CascadeType.ALL], orphanRemoval = true)
    var family: Family? = null

    constructor()

    constructor(id: Long) {
        this.id = id
    }

    constructor(id: Long, firstName: String, lastName: String, gender: Gender) {
        this.id = id
        this.firstName = firstName
        this.lastName = lastName
        this.gender = gender
    }

    fun addIncome(income: Income) {
        income.person = this
        this.incomes.add(income)
    }

    fun removeIncome(income: Income) {
        this.incomes.remove(income)
    }

    fun getIncomes(): Set<Income> {
        return Collections.unmodifiableSet(incomes)
    }

    fun addCharge(charge: Charge) {
        charge.person = this
        this.charges.add(charge)
    }

    fun removeCharge(charge: Charge) {
        this.charges.remove(charge)
    }

    fun getCharges(): Set<Charge> {
        return Collections.unmodifiableSet(charges)
    }

    fun getNotes(): Set<Note> {
        return Collections.unmodifiableSet(notes)
    }

    fun addNote(note: Note) {
        this.notes.add(note)
    }

    fun removeNote(note: Note) {
        this.notes.remove(note)
    }

    fun getParticipations(): Set<Participation> {
        return Collections.unmodifiableSet(participations)
    }

    fun addParticipation(participation: Participation) {
        participation.person = this
        participations.add(participation)
    }

    fun removeParticipation(participation: Participation) {
        participations.remove(participation)
    }

    fun clearParticipations() {
        participations.clear()
    }

    fun getWeddingEvents(): Set<WeddingEvent> {
        return Collections.unmodifiableSet(weddingEvents)
    }

    fun addWeddingEvent(weddingEvent: WeddingEvent) {
        weddingEvent.person = this
        weddingEvents.add(weddingEvent)
    }

    fun removeWeddingEvent(weddingEvent: WeddingEvent) {
        weddingEvents.remove(weddingEvent)
    }

    fun getNetworkMembers(): Set<NetworkMember> {
        return Collections.unmodifiableSet(networkMembers)
    }

    fun addNetworkMember(networkMember: NetworkMember) {
        networkMember.person = this
        networkMembers.add(networkMember)
    }

    fun removeNetworkMember(networkMember: NetworkMember) {
        networkMembers.remove(networkMember)
    }
}
