package org.globe42.web.security

import java.security.NoSuchAlgorithmException
import java.security.SecureRandom
import java.security.spec.InvalidKeySpecException
import java.security.spec.KeySpec
import java.util.Arrays
import java.util.Base64
import javax.crypto.SecretKeyFactory
import javax.crypto.spec.PBEKeySpec

import org.springframework.stereotype.Component

/**
 * Component allowing to salt, hash and base64-encode passwords, as well as match passwords against encoded passwords
 * @author JB Nizet
 */
@Component
class PasswordDigester {

    /**
     * Generates a salt, hashes the password with this salt, concatenates the salt and the hash, and encodes
     * the result using Base64
     */
    fun hash(password: String): String {
        val salt = generateSalt()
        val digest = hash(password, salt)
        val concatenation = concat(salt, digest)
        return Base64.getEncoder().encodeToString(concatenation)
    }

    /**
     * concat two byte arrays into one
     *
     * @param first  - the first array
     * @param second - the second array
     * @return a concatenated array
     */
    private fun concat(first: ByteArray, second: ByteArray): ByteArray {
        val concatenation = ByteArray(first.size + second.size)
        System.arraycopy(first, 0, concatenation, 0, first.size)
        System.arraycopy(second, 0, concatenation, first.size, second.size)
        return concatenation
    }

    /**
     * Verifies a password against a hashed password generated by [.hash]
     */
    fun match(password: String, hashedPassword: String?): Boolean {
        if (hashedPassword == null) {
            return false
        }
        val concatenation = Base64.getDecoder().decode(hashedPassword)
        val salt = Arrays.copyOfRange(concatenation, 0, SALT_LENGTH)
        val digest = Arrays.copyOfRange(concatenation, SALT_LENGTH, concatenation.size)
        val newDigest = hash(password, salt)
        return Arrays.equals(newDigest, digest)
    }

    companion object {

        private val SALT_LENGTH = 8
        val ITERATION_COUNT = 4096
        val KEY_LENGTH = 256

        private fun generateSalt(): ByteArray {
            try {
                val salt = ByteArray(SALT_LENGTH)
                SecureRandom.getInstance("SHA1PRNG").nextBytes(salt)
                return salt
            } catch (e: NoSuchAlgorithmException) {
                throw IllegalStateException(e)
            }

        }

        private fun hash(password: String, salt: ByteArray): ByteArray {
            try {
                val factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256")
                val keySpec = PBEKeySpec(password.toCharArray(), salt, ITERATION_COUNT, KEY_LENGTH)
                val secretKey = factory.generateSecret(keySpec)
                return secretKey.encoded
            } catch (e: NoSuchAlgorithmException) {
                throw IllegalStateException(e)
            } catch (e: InvalidKeySpecException) {
                throw IllegalStateException(e)
            }

        }

        @JvmStatic
        fun main(args: Array<String>) {
            println("hashed(password) = " + PasswordDigester().hash("password"))
        }
    }
}
