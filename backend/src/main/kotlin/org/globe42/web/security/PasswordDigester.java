package org.globe42.web.security;

import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import java.util.Arrays;
import java.util.Base64;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;

import org.springframework.stereotype.Component;

/**
 * Component allowing to salt, hash and base64-encode passwords, as well as match passwords against encoded passwords
 * @author JB Nizet
 */
@Component
public class PasswordDigester {

    private static final int SALT_LENGTH = 8;
    public static final int ITERATION_COUNT = 4096;
    public static final int KEY_LENGTH = 256;

    /**
     * Generates a salt, hashes the password with this salt, concatenates the salt and the hash, and encodes
     * the result using Base64
     */
    public String hash(String password) {
        byte[] salt = generateSalt();
        byte[] digest = hash(password, salt);
        byte[] concatenation = concat(salt, digest);
        return Base64.getEncoder().encodeToString(concatenation);
    }

    /**
     * concat two byte arrays into one
     *
     * @param first  - the first array
     * @param second - the second array
     * @return a concatenated array
     */
    private byte[] concat(byte[] first, byte[] second) {
        byte[] concatenation = new byte[first.length + second.length];
        System.arraycopy(first, 0, concatenation, 0, first.length);
        System.arraycopy(second, 0, concatenation, first.length, second.length);
        return concatenation;
    }

    /**
     * Verifies a password against a hashed password generated by {@link #hash(String)}
     */
    public boolean match(String password, String hashedPassword) {
        if (hashedPassword == null) {
            return false;
        }
        byte[] concatenation = Base64.getDecoder().decode(hashedPassword);
        byte[] salt = Arrays.copyOfRange(concatenation, 0, SALT_LENGTH);
        byte[] digest = Arrays.copyOfRange(concatenation, SALT_LENGTH, concatenation.length);
        byte[] newDigest = hash(password, salt);
        return Arrays.equals(newDigest, digest);
    }

    private static byte[] generateSalt() {
        try {
            byte[] salt = new byte[SALT_LENGTH];
            SecureRandom.getInstance("SHA1PRNG").nextBytes(salt);
            return salt;
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException(e);
        }
    }

    private static byte[] hash(String password, byte[] salt) {
        try {
            SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
            KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, ITERATION_COUNT, KEY_LENGTH);
            javax.crypto.SecretKey secretKey = factory.generateSecret(keySpec);
            return secretKey.getEncoded();
        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
            throw new IllegalStateException(e);
        }
    }

    public static void main(String[] args) {
        System.out.println("hashed(password) = " + new PasswordDigester().hash("password"));
    }
}
